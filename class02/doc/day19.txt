# day19

래퍼 클래스
==> 주소를 사용하는 곳에 Value Type을 사용할 수 없는 문제가 생길 수 있다.
	이런 문제를 해결하기 위해서 만든 클래스를 래퍼 클래스라고 한다.(Wrapper Class)
	즉 예를 들어 int 주소를 사용할 수(int 를 객체로 사용할 수) 있도록 하기 위해 만든 클래스
	
	Object obj = 10;
	의 경우 오브젝트의 하위의 클래스로 데이터가 형변환이 되어야 변수에 담을 수 있다.
	
	
	참고 ]
		자바는 Object를 중심으로 계층 구조화해서
		클래스를 이용하도록 만드는 객체지향 언어이다.
		
		그런데 유일하게 Value Type(boolean, char, byte, short, int, ....) 만큼은
		객체지향 원리를 사용하지 않는다.
		따라서 다형성 구현에 있어서 약간의 문제가 생겼다.
		
		
	예 ]
		void abc(Object o){
		}
		==> 이 함수는 모든 내용을 처리하도록 만든 함수이다.
			그런데 이때 유일하게 Value Type은 줄 수 없는 상황이 일어날 수 있다.
			
			==> 따라서 이런 문제를 해결하기 위해서 만들어진 클래스 들을 래퍼클래스라고 한다.
			
	참고 ]
		
		Boxing과 UnBoxing
			
			Boxing 		- Value Type을 주소 타입으로 변환하는 것.
			UnBoxing	- Heap 영역에 있는 데이터를 다시 Stack으로 꺼내는 것.
						  주소 타입을 Value Type으로 변환시키는 것.
						  
	참고 ]
		그런데 이제는 래퍼 클래스를 몰라도 된다.
		왜냐하면 버젼 1.4 이후 부터는 Boxing, UnBoxing이 
		자동으로 처리된다.
		
		예 ]
			Integer no = 10; 	==> 자동 박싱
			int no2 = no;		==> 자동 언박싱
			
	결론 ]
		자바는 내부적으로 모든 정보를 주소를 통해서 사용할 수 있다.
		(모든 정보를 객체로 만들어서 사용할 수 있다.)
		
	참고 ]
		다만 유틸리티적인 몇개의 함수는 아직 이용 가능 하므로
		완전히 버려진 클래스는 아니다.
		
		예 ]
			
			Integer.parseInt()
			Float.parseFloat()
			Double.parseDouble()
			
------------------------------------------------------------------------------------------------------------------

java.util 패키지 소속의 유용한 클래스

1. Objects
	==> 이 클래스는 100% static 함수로만 구성된 클래스
		클래스(객체)를 다룰 때 유용한 몇가지 유틸리티적인 함수로 구성된 클래스이다.
		
		예 ]
			isNull(Object obj)
			==>	객체의 내용이 있는지를 확인하는 함수
				즉, new 시킨 결과가 있는 지를 확인하는 함수
				
				ArrayList list;
				
				Objects.isNull(list); ==> true
				
			참고 ]
				
				null 이란?
				==> 주소 변수에 주소가 없는 상태를 말하는 것이다.
					참조형 변수에 담겨진 내용이 없다는 것.
					
					이것은 찾아갈 대상이 없다는 것이고
					아직 사용할 준비가 되지 않았다는 것이다.
					
------------------------------------------------------------------------------------------------------------------
Random 클래스
==> 난수를 발생하는 클래스
	우리가 사용하던 Math.random() 보다는
	좀더 다양한 형태의 난수를 발생할 수 있는 장점이 있다.
	
	참고 ]
		
		seed 란?
			컴퓨터의 난수 발생은 
			요청하는 순간 실제로 난수를 만들어주는 것이 아니고
			이미 컴퓨터 내부에 난수 테이블이 존재하고 있다.
			그리고 그 난수 테이블에서 순서대로 꺼내서 주는 역할을 하고 있다.
			seed 란 난수 테이블에서 난수를 꺼내는 위치를 말하는 용어이다.

-----------------------------------------------------------------------------------------------------------------

Arrays 클래스
==> 이 클래스 역시 100% static 함수로만 구성된 클래스
	배열을 처리할 때 필요한 유틸리티적인 함수들로 구성된 클래스이다.
	
	예 ]
		sort(???)
		==> 배열에 있는 데이터를 정렬하는 기능을 가진 함수
		
		Arrays.toString(배열);
		
		Math.PI
		
---------------------------------------------------------------------------------------------------------------
Scanner
==> 외부 장치를 이용해서 데이터를 받아들이기 위한 클래스
	
	참고 ]
		원래 자바는 IO 라는 개념을 이용해서 외부장치와 연결한다.
		그러다 보니 간단한 테스를 위해서도 IO 처리를 해야하므로
		개발자가 매우 불편하다.
		
		1.5 버젼 부터 만들어진 기능이다.
		
		
	생성자 함수 ]
		
		==> 외부장치인 File 이나 IO인 Stream을 넣어달라고 하고 있다.
		
	참고 ]
		System.in 이라는 스트림이 있다.
		==> 내부적으로 키보드하고 연결한 스트림으로 만들어 놓은 것이다.
		
	우리가 
	Scanner sc = new Scanner(System.in);
	==> 키보드를 통해서 입력받는 Scanner가 된 것이다.
	
-----------------------------------------------------------------------------------------------------------------

StringTokenizer
==> 하나의 문자열을 원하는 문자를 중심으로 나누어주는 기능을 가진 클래스
	
	사용이유 ]
		네트워크등을 이용하면
		여러개의 데이터가 한번에 들어올 수 있다.
		
		예 ]
			
			http://www.increpas.com/member/login.inc?id=euns&pw=12345
	
			위의 경우나
			
			카톡의 경우
			보낸사람, 보낸시간, 내용, ... 이
			하나의 문자열로 구성되어서 한번에 전송이 되어 들어게 된다.
			==> 이런 경우에 각각의 데이터를 분리해서 처리해야 한다.
				
				xxx=xxx&xxx=xxxx
				
				
	생성방법 ]
		1. StringTokenizer(String str)
			==> 문자열을 공백을 기준으로 나눠준다.
			
		2. StringTokenizer(String str, String delim)
			==> 문자열을 지정한 문자(String delim)을 중심으로 나눠주는 기능
			
				만약 delim 구분자를 문자열로 입력하는 경우는
				각 문자별로 짜르게 된다.
				
				String str = "a,b|c&d";
				
				StringTokenizer token = new StringTokenizer(str, ",|&"); ==> "," || "|" || "&" 의 의미가 된다.
		
		3. StringTokenize(String str, String delim, boolean returnDelims)
			==> 2번 기능에 분리 문자도 추가할지 말지를 결정해서 나눠준다.
			
	주의사항 ]
		==> 	분리된 결과는 임시 버퍼(스텍)에 기억이 되어 있다.
				따라서 이것은 한번 사용하면 더이상 사용할 수 없게 되고
				반드시 순서대로 꺼내야 한다.
				
				
	주요함수 ]
		countTokens()							==> 나눠진 결과수 반환
		hasMoreElments() | hasMoreTokens()		==> 아직 임시버퍼에 내용이 남아 있는지 여부를 반환해준다.
		nextElement()							==> 꺼낸 결과를 Object 타입으로 반환
		nextToken()								==> 꺼낸 결과를 문자열로 반환
	
	
-----------------------------------------------------------------------------------------------------------------
BigDecimal
==> 정수로 표현할 수 없는 숫자를 사용하기 위한 클래스이다.
	
	주로 데이터베이스와 연동할 때(연결해서 작업할 때)
	오라클의 데이터 형태는 
		NUMBER(숫자)
	의 형태로 정의 하는데 이때 숫자는 자리수를 이야기하고 
	오라클에서는 38자리까지 허용한다.
	그런데 이런 데이터는 자바에서는 기억할 방법이 없었다.
	따라서 이런 유형의 데이터를 처리하기 위해서 만들어진 클래스이다.
	
	예 ]
		
		BigDecimal big = new BigDecimal("12345678901234567890123456789012345678");
		
		
	참고 ]
		BigDecimal 클래스에 정의 되어있는 함수를 공부해두세요...
		
-----------------------------------------------------------------------------------------------------------------

정규식 검사
==> 주어진 문자열이 특정한 규칙에 맞도록 만들어져 있는지를 확인하는 기능
	
	예 ]
		주민등록번호가 6자리-7자리 숫자로 구성되어 있는지??
		아이디가 순수하게 숫자와 문자로만 구성되어 있는지???
		비번이 영문 대소문자를 포함하고 숫자도 포함하고 특수문자가 적어도 한개를 포함하고 8자리 이상으로 만들어져 있는지???
		
		
	사용하는 클래스
		
		java.util.regex.Pattern
		==> 정규식 검사에 사용할 정규식 문법(형식)을 지정할 클래스
		
		java.util.regex.Matcher
		==> 정규식 검사를 실제로 실행할 클래스
	
	
	참고 ]
		정규식 문법
			
			1. c[a-z]*
				==>	글자를 기술하면 반드시 그 위치에 그 글자가 와야한다.
					[]안에 기록하면 그 중 하나가 와야한다.
					*는 바로앞에 지정한 글자가 0개이상 와야 한다.
					
			==> c로 시작하고 알파벳 소문자가 0개이상 오면 된다.
				==> cabc --- O
					c	---- O
					cz	---- O
					cC	---- X
					c1	---- X
					
			2. c[a-z]
				==> c로 시작하고 다음 문자는 알파벳 소문자가 한개와야한다.
				
			3. c[a-zA-Z]
				==> c로 시작하고 다음 문자는 알파벳이면 된다.(c 이후의 문자는 대소문자 구분안한다.)
				
			4. c[a-zA-Z0-9]
				==> c로 시작하고 다음 글자는 알파벳 문자와 숫자가 와야한다.
					
					이것은 
						c\w 
					로 줄여서 표현하기도 한다.
					
			5. .*
				==> .은 모든 문자(알파벳과 한글까지 포함)를 의미한다.
				==> 모든글자가 와도 상관없다.
				
			6. c.
				==> 두글잔데 시작은 c로 시작하고 다음 문자는 모든 문자중 하나가 와야한다.
				
			7. c.*
				==> c로 시작하고 다음은 모든문자가 몇개가 와도 상관없다.
				
			8. c\.
				==> \. 은 반드시 문자 . 만 와야한다.
				==> c. 이어야 한다.
				
			9. c.*t
				==> 첫글자는 c로 시작하고 아무문자나 몇글자가 와도 상관없는데 마지막 글자는 t가 와야한다.
				
			10. c\d
				==> \d - 숫자형태 문자를 의미
				==> 첫글자는 c가 와야하고 그 다음은 숫자형태의 문자가 하나 와야한다.
				
			11. [b|c].* ==> [bc].*
				
				==>  b또는 c가 시작되어야 하고 
					다음은 어떤 문자가 몇개가 와도 상관없다.
					
			12. [^b|c]
				==> ^ 는 NOT의 의미
				==> b 또는 c가 아닌 문자가 한개
			
			13. .*a.*
				==> a라는 문자가 한글자가 포함되면 된다.
				
			14. .*a.+
				==> * : 0글자 이상의 의미
					+ : 1글자 이상의 의미
					
					예 ]
						
						a가 ------ O
						a가나 ---- O
						가a ------ X
					
			15. [b|c].{2}
				==> b 또는 c로 시작하고
					이후에 어떤문자라도 2글자가 와야한다.
					{숫자} ==> 글자수
					
			16. .{2,3}
				==> {숫자1, 숫자2} 는 글자 수를 의미하는데 OR의 의미를 가진다.
					
					예 ]
						
						\d{2,3}
						==> 숫자가 두개 또는 3개
						
			17. \\w{3,}
				==> 알파벳 또는 숫자가 3개 이상 와야한다.
					
					
			
						
				[a-zA-Z0-9!@#$%^&*_-+=]
				
				
	정규 표현식 중
		
		전방탐색자 에 대해서 검색하고 공부해오세요...!
						
-----------------------------------------------------------------------------------------------------------------
	
	
	
	
	
			
	
	